<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>X (IFrame)</title>
		<meta content="width=device-width, initial-scale=1.0" name="viewport">
		<meta content="yes" name="mobile-web-app-capable">
		<link rel="stylesheet" href="log.css">
		<script>
			'use strict'
			function a(){
				function isIframe(){
					try{
						return window.self !== window.top;
					}catch(e){
						return true;
					}
				}
				if(isIframe()){
					let _parent = null;
					let _arenaWorkers = [];
					let _arenaResponses = [];
					let _arenaPromises = [];
					let _arenaReadyToStart = [];
					let _scriptLoaded_promises = [];
					let _messageQueue = [];
					let _messagePending = [];
					window.onmessage = messageEvent => {
						_parent = {
							source: messageEvent.source,
							origin: messageEvent.origin
						};
						let _data = messageEvent.data;
						if(_data.settings.general.seed === ''){
							_data.settings.general.seed += (''+Math.random()).replace(/^.*\./,'');
						}
						let _freeMessageChannels = Math.max(1, navigator.hardwareConcurrency-(1+_data.settings.general.bestOf));
						function nextMessage(){
							let message = _messageQueue.pop();
							if(message !== undefined){
								let iframe = document.getElementById(message.receiver);
								if(iframe === null){
									console.error('Receiver missing: '+message.receiver+'\n'+JSON.stringify(message.body));
									nextMessage();
								}else{
									_messagePending.push(message);
									iframe.contentWindow.postMessage(message.body, '*');
								}
							}
						}
						if(location.href.includes('?debug')){
							_data.debug = true;
						}
						[_data.urls.ArenaHelper, _data.urls.randomseed].forEach(url => {
							let script = document.createElement('script');
							let scriptLoaded;
							_scriptLoaded_promises.push(new Promise(resolve => scriptLoaded = resolve));
							script.onload = function(){
								scriptLoaded();
							}
							script.src = url;
							document.head.appendChild(script);
						});
						function blockNetwork(){
							window.stop();
							window.requestAnimationFrame(blockNetwork);
						}
						function addWorker(data){
							let iframe = document.getElementById(data.iframeId);
							if(iframe === null){
								iframe = document.createElement('iframe');
								iframe.id = data.iframeId;
								iframe.src = 'iframe.sandbox.participant.worker.html?'+data.iframeId+'#'+_data.urls.ArenaHelper;
								iframe.sandbox = 'allow-scripts';
								document.body.appendChild(iframe);
								setTimeout(()=>{
									console.log('// TODO: Change from setTimeout to `Sandbox-Participant-Worker-Initiated`, like ReplayHelper.');
									iframe.contentWindow.postMessage({
										url: data.url,
										name: data.name,
										participant: data.participant,
										workerData: data.workerData,
										includeScripts: [..._data.arena.includeScripts.participants, _data.urls.randomseed, _data.urls.ParticipantHelper]
									}, '*');
								}, 1000);
							}else{
								_arenaWorkers[data.source.matchIndex].postMessage('Participant-worker "'+data.iframeId+'" already exist!');
							}
						}
						function messageWorker(message){
							_messageQueue.push(message);
							if(_messagePending.length < _freeMessageChannels){
								nextMessage();
							}
						}
						if(_data.arena !== undefined){
							window.onmessage = messageEvent => {
								if(messageEvent.data.data.payload.systemMessage){
									switch(messageEvent.data.data.payload.message){
										default: throw new Error('SystemMessage "'+messageEvent.data.data.payload.message+'" not found.');
										case 'Dead':
											let iframe = document.getElementById(messageEvent.data.data.source.iframeId);
											iframe.parentNode.removeChild(iframe);
											break;
									}
								}
								_arenaWorkers[messageEvent.data.data.source.matchIndex].postMessage(messageEvent.data);
								if(messageEvent.data.data.event.startsWith('Message')){
									let index = _messagePending.findIndex(m => m.receiver === messageEvent.data.data.source.iframeId);
									if(index !== -1){
										_messagePending.splice(index, 1);
									}
									if(0 < _messageQueue.length){
										nextMessage();
									}
								}
							}
							document.title = document.title.replace('X', _data.arena.full_name);
							function checkLimits(json){
								let limits = json.header.limits;
								let participants = JSON.parse(JSON.stringify(_data.participants));
								return limits.teams.min === undefined ? true : limits.teams.min <= participants.length
								&& limits.teams.max === undefined ? true : participants.length <= limits.teams.max
								&& limits.participants.min === undefined ? true : limits.participants.min <= participants.flat().length
								&& limits.participants.max === undefined ? true : participants.flat().length <= limits.participants.max
								&& limits.participantsPerTeam.min === undefined ? true : limits.participantsPerTeam.min <= participants.sort((x,y)=>y.length-x.length)[0].length
								&& limits.participantsPerTeam.max === undefined ? true : participants.sort((x,y)=>x.length-y.length)[0].length <= limits.participantsPerTeam.max;
							}
							fetch(_data.arena.raw_url+'properties.json')
							.then(response => response.json())
							.then(json => {
								if(checkLimits(json)){
									Promise.allSettled(_scriptLoaded_promises).then(() => {
										Math.seedrandom(_data.settings.general.seed);
										let arenaSetup_promises = [];
										let arenas = [];
										for(let index = 0; index < _data.settings.general.bestOf; index++){
											let arenaSetup;
											arenaSetup_promises.push(new Promise(r=>arenaSetup=r));
											ArenaHelper.CreateWorkerFromRemoteURL(_data.arena.raw_url+'arena.js', [..._data.arena.includeScripts.arena, _data.urls.randomseed, _data.urls.ArenaHelper]).then(arena => {
												arenas.push(arena);
												let readyToStart;
												_arenaReadyToStart.push(new Promise(r=>readyToStart=r));
												let resolve;
												_arenaPromises.push(new Promise(r=>resolve=r));
												arenaSetup();
												_arenaWorkers[index] = arena;
												let callbacks = {
													'Add-Worker': addWorker,
													'Message-Worker': messageWorker,
													'Ready-To-Start': readyToStart
												};
												arena.onmessage = messageEvent => {
													let callback = callbacks[messageEvent.data.type];
													if(callback === undefined){
														switch(messageEvent.data.type){
															default:
																throw new Error('Callback "'+callback+'" not found.');
															case 'Aborted':
																if(_data.debug){
																	debugger;
																}
															case 'Done':
																arena.terminate();
																_arenaResponses[index] = {...messageEvent.data.message, status: messageEvent.data.type};
																resolve();
																break;
														}
													}else{
														callback(messageEvent.data.message);
													}
												};
												let arenaInput = {...JSON.parse(JSON.stringify(_data)), matchIndex: index};
												arenaInput.settings.general.seed += '#'+(''+Math.random()).replace(/^.*\./,''); // Get salt from Math.seedrandom.
												arena.onerror = errorEvent => {
													let message = errorEvent.message+' @ '+errorEvent.lineno+':'+errorEvent.colno;
													console.error(message);
													arena.terminate();
													_arenaResponses[index] = {
														status: 'Aborted',
														error: message,
														participantName: arenaInput.arena.full_name,
														settings: arenaInput.settings,
														log: []
													};
													resolve();
												};
												arena.postMessage(arenaInput);
											});
										}
										Promise.allSettled(arenaSetup_promises).then(()=>{
											Promise.allSettled(_arenaReadyToStart).then(()=>{
												if(!_data.settings.general.advanced.allowRemoteExecution){
													blockNetwork();
												}
												arenas.forEach(arena=>arena.postMessage({type: 'Start'}));
											});
											Promise.allSettled(_arenaPromises).then(()=>{
												function getTeamColor(teamIndex){
													let hue = ((teamIndex/_data.participants.length)+.5)%1;
													let saturation = 0.5;
													let lightness = 0.5;
													let _q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
													let _p = 2 * lightness - _q;
													function hue2rgb(_p, _q, _t){
														if(_t < 0){_t += 1;}
														if(_t > 1){_t -= 1;}
														if(_t < 1/6.0){return _p + (_q - _p) * 6 * _t;}
														if(_t < 1/2.0){return _q;}
														if(_t < 2/3.0){return _p + (_q - _p) * (2/3.0 - _t) * 6;}
														return _p;
													}
													let returnObject = {
														R: hue2rgb(_p, _q, hue + 1/3.0),
														G: hue2rgb(_p, _q, hue),
														B: hue2rgb(_p, _q, hue - 1/3.0)
													}
													let red = Math.round(256*returnObject.R).toString(16);
													if(red.length === 1){
														red = '0'+red;
													}
													let green = Math.round(256*returnObject.G).toString(16);
													if(green.length === 1){
														green = '0'+green;
													}
													let blue = Math.round(256*returnObject.B).toString(16);
													if(blue.length === 1){
														blue = '0'+blue;
													}
													returnObject.RGB = '#'+red+green+blue
													return returnObject;
												}
												let result = {
													team: [],
													partialResult: false
												};
												_arenaResponses.forEach(responses => {
													responses.seed = responses.settings.general.seed;
													delete responses.settings;
													if(responses.scores){
														responses.scores.forEach(score => {
															if(!result.team[score.team]){
																result.team[score.team] = {
																	average: {
																		score: 0,
																		bonusPoints: []
																	},
																	total: {
																		score: 0,
																		bonusPoints: []
																	}
																};
															}
															result.team[score.team].total.score += score.score;
															score.members.forEach(member => {
																let individualBonus = result.team[score.team].total.bonusPoints.find(b => b.participant === member.name && b.team === score.team);
																if(!individualBonus){
																	individualBonus = {
																		participant: member.name,
																		team: score.team,
																		bonus: 0
																	}
																	result.team[score.team].average.bonusPoints.push(individualBonus);
																	result.team[score.team].total.bonusPoints.push(JSON.parse(JSON.stringify(individualBonus)));
																}
																individualBonus.bonus += member.bonus;
															});
														});
													}else{
														result.partialResult = true;
													}
												});
												let dominator = _arenaResponses.filter(r => r.scores).length;
												result.team.forEach(teamScore => {
													teamScore.average.score = teamScore.total.score/dominator;
													teamScore.average.bonusPoints.forEach(individualBonus => {
														individualBonus.bonus = individualBonus.bonus/dominator;
													});
												});
												let teams = [];
												_data.participants.forEach((t, index) => {
													let team = {};
													teams.push(team);
													team.color = getTeamColor(index);
													team.members = JSON.parse(JSON.stringify(t.map(m => m.name)));
												});
												_parent.source.postMessage({
													iframeID: _data.iframeID,
													defaultReplay: _data.urls.replay,
													value: {
														arena: {
															full_name: _data.arena.full_name,
															commit: _data.arena.commit,
															version: _data.arena.version
														},
														settings: _data.settings,
														matchLogs: _arenaResponses,
														result: result,
														teams: teams
													}
												}, _parent.origin);
											});
										});
									});
								}else{
									let message = 'Participants does not meet the arena limitations.';
									document.body.innerHTML += '<label for="message_limit_error" class="Error">Error</label><pre id="message_limit_error" class="Error">'+message+'</pre>';
									console.error(message);
								}
								console.log('// TODO: Optimize and removed unused functions. Is document.body.innerHTML used?');
							});
						}
					}
				}else{
					window.location.replace(window.location.href.replace('\/(?:.(?!\/))+$', '/'));
				}
			}
		</script>
	</head>
	<body onload="a()"></body>
</html>
